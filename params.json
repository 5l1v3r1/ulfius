{
  "name": "Ulfius",
  "tagline": "Web Framework for json REST API in C",
  "body": "# Ulfius\r\n\r\nWeb Framework for REST Applications in C.\r\n\r\nBased on [GNU Libmicrohttpd](https://www.gnu.org/software/libmicrohttpd/) for the backend web server, [Jansson](http://www.digip.org/jansson/) for the json manipulation library, and [Libcurl](http://curl.haxx.se/libcurl/) for the http/smtp client API.\r\n\r\nUsed to facilitate creation of web applications in C programs with a small memory footprint, as in embedded systems applications.\r\n\r\n## Hello World! example application\r\n\r\nThe source code of a hello world using Ulfius could be the following:\r\n\r\n```c\r\n/**\r\n * test.c\r\n * Small Hello World! example\r\n * to compile with gcc, run the following command\r\n * gcc -o test test.c -lulfius\r\n */\r\n#include <ulfius.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n\r\n#define PORT 8080\r\n\r\n/**\r\n * Callback function for the web application on /helloworld url call\r\n */\r\nint callback_hello_world (const struct _u_request * request, struct _u_response * response, void * user_data) {\r\n  ulfius_set_string_response(response, 200, \"Hello World!\");\r\n  return U_OK;\r\n}\r\n\r\n/**\r\n * main function\r\n */\r\nint main(void) {\r\n  struct _u_instance instance;\r\n\r\n  // Initialize instance with the port number\r\n  if (ulfius_init_instance(&instance, PORT, NULL) != U_OK) {\r\n    fprintf(stderr, \"Error ulfius_init_instance, abort\\n\");\r\n    return(1);\r\n  }\r\n\r\n  // Endpoint list declaration\r\n  ulfius_add_endpoint_by_val(&instance, \"GET\", \"/helloworld\", NULL, NULL, NULL, NULL, &callback_hello_world, NULL);\r\n\r\n  // Start the framework\r\n  if (ulfius_start_framework(&instance) == U_OK) {\r\n    printf(\"Start framework on port %d\\n\", instance.port);\r\n\r\n    // Wait for the user to press <enter> on the console to quit the application\r\n    getchar();\r\n  } else {\r\n    fprintf(stderr, \"Error starting framework\\n\");\r\n  }\r\n  printf(\"End framework\\n\");\r\n\r\n  ulfius_stop_framework(&instance);\r\n  ulfius_clean_instance(&instance);\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\n# Prerequisites\r\n\r\n## External dependencies\r\n\r\nTo install the external dependencies, for Debian based distributions (Debian, Ubuntu, Raspbian, etc.), run as root:\r\n\r\n```shell\r\n# apt-get install libmicrohttpd-dev libjansson-dev libcurl4-gnutls-dev\r\n```\r\n\r\n### Note\r\n\r\nI write libcurl4-gnutls-dev for the example, but any `libcurl*-dev` library should be sufficent, depending on your needs and configuration.\r\n\r\n# Installation\r\n\r\nDownload Ulfius source code from Github, get the submodules, compile and install:\r\n\r\n```shell\r\n$ git clone https://github.com/babelouest/ulfius.git\r\n$ cd ulfius/\r\n$ git submodule update --init\r\n$ make\r\n$ sudo make install\r\n```\r\n\r\nBy default, the shared libraries and the header files will be installed in the `/usr/local` location. To change this setting, you can modify the `PREFIX` value in the `src/Makefile`, `lib/orcania/Makefile` and `lib/yder/src/Makefile` files.\r\n\r\n## libcurl older than 7.20\r\n\r\nIf you use old version of liburl, as in Centos 6.5 for example, `ulfius_send_smtp_email` won't be available due to libcurl options problems. In this case, uncomment the following line in the file `src/Makefile`:\r\n\r\n```Makefile\r\n#SMTPFLAGS=-DULFIUS_IGNORE_SMTP\r\n```\r\n\r\nThis will disable `ulfius_send_smtp_email` during the compilation.\r\n\r\n# API Documentation\r\n\r\n## Header file\r\n\r\nInclude file `ulfius.h` in your source file:\r\n\r\n```c\r\n#include <ulfius.h>\r\n```\r\n\r\nOn your linker command, add ulfius as a dependency library, e.g. `-lulfius` for gcc.\r\n\r\n## API Documentation\r\n\r\n### Return values\r\n\r\nWhen specified, some functions return `U_OK` on success, and other values otherwise. `U_OK` is 0, other values are non-0 values. The defined return value list is the following:\r\n```c\r\n#define U_OK                 0 // No error\r\n#define U_ERROR              1 // Error\r\n#define U_ERROR_MEMORY       2 // Error in memory allocation\r\n#define U_ERROR_PARAMS       3 // Error in input parameters\r\n#define U_ERROR_LIBMHD       4 // Error in libmicrohttpd execution\r\n#define U_ERROR_LIBCURL      5 // Error in libcurl execution\r\n#define U_ERROR_NOT_FOUND    6 // Something was not found\r\n#define U_ERROR_UNAUTHORIZED 7 // No authorization given\r\n```\r\n\r\n### Initialization\r\n\r\nWhen initialized, Ulfius runs a thread in background that will listen to the specified port and dispatch the calls to the specified functions. Ulfius allows adding and removing new endpoints during the instance execution.\r\n\r\nTo run a webservice, you must initialize a `struct _u_instance` and add your endpoints.\r\n\r\nThe `struct _u_instance` is defined as:\r\n\r\n```c\r\n/**\r\n * \r\n * Structure of an instance\r\n * \r\n * Contains the needed data for an ulfius instance to work\r\n * \r\n * mhd_daemon:            pointer to the libmicrohttpd daemon\r\n * status:                status of the current instance, status are U_STATUS_STOP, U_STATUS_RUNNING or U_STATUS_ERROR\r\n * port:                  port number to listen to\r\n * bind_address:          ip address to listen to (optional)\r\n * nb_endpoints:          Number of available endpoints\r\n * endpoint_list:         List of available endpoints\r\n * default_endpoint:      Default endpoint if no other endpoint match the current url\r\n * default_headers:       Default headers that will be added to all response->map_header\r\n * default_auth_function: Default callback function used for authentication (optional)\r\n *                        a pointer to a function used to check the client credentials\r\n *                        this function will be called prior to the callback function. If default_auth_function returned value is U_OK,\r\n *                        then the callback function will be called after. If default_auth_function is not U_OK, response status send will be\r\n *                        401 (Unauthorized), and callback_function will be skipped\r\n *                        If an endpoint already has a auth_callback set, the default_auth_function will not be called\r\n *                        but the auth_callback function of the endpoint will\r\n * default_auth_data:     a pointer to a data or a structure that will be available in auth_function\r\n * default_auth_realm:    realm value for authentication\r\n * max_post_param_size:   maximum size for a post parameter, 0 means no limit, default 0\r\n * max_post_body_size:    maximum size for the entire post body, 0 means no limit, default 0\r\n * \r\n */\r\nstruct _u_instance {\r\n  struct MHD_Daemon          *  mhd_daemon;\r\n  int                           status;\r\n  int                           port;\r\n  struct sockaddr_in          * bind_address;\r\n  int                           nb_endpoints;\r\n  struct _u_endpoint          * endpoint_list;\r\n  struct _u_endpoint          * default_endpoint;\r\n  struct _u_map               * default_headers;\r\n  int (* default_auth_function)(const struct _u_request * request, // Input parameters (set by the framework)\r\n                                struct _u_response * response,     // Output parameters (set by the user)\r\n                                void * auth_data);\r\n  void *                        default_auth_data;\r\n  char *                        default_auth_realm;\r\n  size_t                        max_post_param_size;\r\n  size_t                        max_post_body_size;\r\n};\r\n```\r\n\r\nIn the `struct _u_instance` structure, the element `port` must be set to the port number you want to listen to, the element `bind_address` is used if you want to listen only to a specific IP address. The element `mhd_daemon` is used by the framework, don't modify it.\r\n\r\nYou can use the functions `ulfius_init_instance` and `ulfius_clean_instance` to facilitate the manipulation of the structure:\r\n\r\n```c\r\n/**\r\n * ulfius_init_instance\r\n * \r\n * Initialize a struct _u_instance * with default values\r\n * return U_OK on success\r\n */\r\nint ulfius_init_instance(struct _u_instance * u_instance, int port, struct sockaddr_in * bind_address);\r\n\r\n/**\r\n * ulfius_clean_instance\r\n * \r\n * Clean memory allocated by a struct _u_instance *\r\n */\r\nvoid ulfius_clean_instance(struct _u_instance * u_instance);\r\n```\r\n\r\nThe `struct _u_endpoint` is defined as:\r\n\r\n```c\r\n/**\r\n * \r\n * Structure of an endpoint\r\n * \r\n * Contains all informations needed for an endpoint\r\n * http_method:       http verb (GET, POST, PUT, etc.) in upper case\r\n * url_prefix:        prefix for the url (optional)\r\n * url_format:        string used to define the endpoint format\r\n *                    separate words with /\r\n *                    to define a variable in the url, prefix it with @ or :\r\n *                    example: /test/resource/:name/elements\r\n *                    on an url_format that ends with '*', the rest of the url will not be tested\r\n * auth_function:     a pointer to a function used to check the client credentials he sent (optional)\r\n *                    this function will be called prior to the callback function. If auth_function returned value is U_OK,\r\n *                    then the callback function will be called after. If auth_function is not U_OK, response status send will be\r\n *                    401 (Unauthorized), and callback_function will be skipped\r\n * auth_data:         a pointer to a data or a structure that will be available in auth_function\r\n * auth_realm:        realm value for authentication\r\n * callback_function: a pointer to a function that will be executed each time the endpoint is called\r\n *                    you must declare the function as described.\r\n * user_data:         a pointer to a data or a structure that will be available in callback_function\r\n * \r\n */\r\nstruct _u_endpoint {\r\n  char * http_method;\r\n  char * url_prefix;\r\n  char * url_format;\r\n  int (* auth_function)(const struct _u_request * request, // Input parameters (set by the framework)\r\n                        struct _u_response * response,     // Output parameters (set by the user)\r\n                        void * user_data);\r\n  void * auth_data;\r\n  char * auth_realm;\r\n  int (* callback_function)(const struct _u_request * request, // Input parameters (set by the framework)\r\n                            struct _u_response * response,     // Output parameters (set by the user)\r\n                            void * user_data);\r\n  void * user_data;\r\n};\r\n```\r\n\r\nSome functions help you facilitate endpoints manipulation:\r\n\r\n```c\r\n/**\r\n * Add a struct _u_endpoint * to the specified u_instance\r\n * Can be done during the execution of the webservice for injection\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * u_endpoint: pointer to a struct _u_endpoint that will be copied in the u_instance endpoint_list\r\n * return U_OK on success\r\n */\r\nint ulfius_add_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint);\r\n\r\n/**\r\n * Add a struct _u_endpoint * to the specified u_instance with its values specified\r\n * Can be done during the execution of the webservice for injection\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * http_method:       http verb (GET, POST, PUT, etc.) in upper case\r\n * url_prefix:        prefix for the url (optional)\r\n * url_format:        string used to define the endpoint format\r\n *                    separate words with /\r\n *                    to define a variable in the url, prefix it with @ or :\r\n *                    example: /test/resource/:name/elements\r\n *                    on an url_format that ends with '*', the rest of the url will not be tested\r\n * auth_function:     a pointer to a function that will be executed prior to the callback for authentication\r\n *                    you must declare the function as described.\r\n * auth_data:         a pointer to a data or a structure that will be available in auth_function\r\n * auth_realm:        realm value for authentication\r\n * callback_function: a pointer to a function that will be executed each time the endpoint is called\r\n *                    you must declare the function as described.\r\n * user_data:         a pointer to a data or a structure that will be available in callback_function\r\n * return U_OK on success\r\n */\r\nint ulfius_add_endpoint_by_val(struct _u_instance * u_instance,\r\n                               const char * http_method,\r\n                               const char * url_prefix,\r\n                               const char * url_format,\r\n                               int (* auth_function)(const struct _u_request * request,\r\n                                                     struct _u_response * response,\r\n                                                     void * auth_data),\r\n                               void * auth_data,\r\n                               char * auth_realm,\r\n                               int (* callback_function)(const struct _u_request * request,\r\n                                                         struct _u_response * response,\r\n                                                         void * user_data),\r\n                               void * user_data);\r\n\r\n/**\r\n * Add a struct _u_endpoint * list to the specified u_instance\r\n * Can be done during the execution of the webservice for injection\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * u_endpoint_list: pointer to an array of struct _u_endpoint ending with a ulfius_empty_endpoint() that will be copied in the u_instance endpoint_list\r\n * return U_OK on success\r\n */\r\nint ulfius_add_endpoint_list(struct _u_instance * u_instance, const struct _u_endpoint ** u_endpoint_list);\r\n\r\n/**\r\n * Remove a struct _u_endpoint * from the specified u_instance\r\n * Can be done during the execution of the webservice for injection\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * u_endpoint: pointer to a struct _u_endpoint that will be removed in the u_instance endpoint_list\r\n * The parameters _u_endpoint.http_method, _u_endpoint.url_prefix and _u_endpoint.url_format are strictly compared for the match\r\n * If no endpoint is found, return U_ERROR_NOT_FOUND\r\n * return U_OK on success\r\n */\r\nint ulfius_remove_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint);\r\n\r\n/**\r\n * Remove a struct _u_endpoint * from the specified u_instance\r\n * using the specified values used to identify an endpoint\r\n * Can be done during the execution of the webservice for injection\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * http_method: http_method used by the endpoint\r\n * url_prefix: url_prefix used by the endpoint\r\n * url_format: url_format used by the endpoint\r\n * The parameters _u_endpoint.http_method, _u_endpoint.url_prefix and _u_endpoint.url_format are strictly compared for the match\r\n * If no endpoint is found, return U_ERROR_NOT_FOUND\r\n * return U_OK on success\r\n */\r\nint ulfius_remove_endpoint_by_val(struct _u_instance * u_instance, const char * http_method, const char * url_prefix, const char * url_format);\r\n\r\n/**\r\n * ulfius_set_default_callback_function\r\n * Set the default callback function\r\n * This callback will be called if no endpoint match the url called\r\n * callback_function: a pointer to a function that will be executed each time the endpoint is called\r\n *                    you must declare the function as described.\r\n * user_data:         a pointer to a data or a structure that will be available in the callback function\r\n * to remove a default callback function, call ulfius_set_default_callback_function with NULL parameter for callback_function\r\n * return U_OK on success\r\n */\r\nint ulfius_set_default_callback_function(struct _u_instance * u_instance,\r\n                                         int (* callback_function)(const struct _u_request * request, struct _u_response * response, void * user_data),\r\n                                         void * user_data);\r\n\r\n/**\r\n * ulfius_set_default_auth_function\r\n * Set the default authentication function\r\n * This authentication function will be called if there is no auth_function attached to the endpoint\r\n * u_instance: pointer to a struct _u_instance that describe its port and bind address\r\n * auth_function:     a pointer to a function that will be executed prior to the callback for authentication\r\n *                    you must declare the function as described.\r\n * auth_data:         a pointer to a data or a structure that will be available in auth_function\r\n * auth_realm:        realm value for authentication\r\n * return U_OK on success\r\n */\r\nint ulfius_set_default_auth_function(struct _u_instance * u_instance,\r\n                                         int (* default_auth_function)(const struct _u_request * request, struct _u_response * response, void * auth_data),\r\n                                         void * default_auth_data,\r\n                                         const char * default_auth_realm);\r\n```\r\n\r\nHTTP Method can be an existing or not existing method, or * for any method, you must specify a url_prefix, a url_format or both, callback_function is mandatory, user_data is optional.\r\n\r\nYour `struct _u_endpoint` array **MUST** end with an empty `struct _u_endpoint`.\r\n\r\nYou can manually declare an endpoint or use the dedicated functions as `int ulfius_add_endpoint` or `int ulfius_add_endpoint_by_val`.\r\n\r\nIf you manipulate the attribute `u_instance.endpoint_list`, you must end the list with an empty endpoint (see `const struct _u_endpoint * ulfius_empty_endpoint()`), and you must set the attribute `u_instance.nb_endpoints` accordingly. Also, you must use dynamically allocated values for attributes `http_method`, `url_prefix` and `url_format`.\r\n\r\nPlease note that each time a call is made to the webservice, endpoints will be tested in the same order. On the first matching endpoint, the other ones won't be tested. So be careful on your endpoints declaration order. If no endpoint is found, an error 404 is raised, except if you set a default endpoint. If you set a default endpoint with `ulfius_set_default_callback_function`, the default callback function will be run if no endpoint match the current url.\r\n\r\nFor example, if you declare the following endpoints in that order:\r\n\r\n```\r\n/test/*\r\n/test/test1\r\n/test/test2\r\n```\r\n\r\nthe last 2 will never be reached because the first one will always be a match for the urls `/test/test1` and `/test/test2`.\r\n\r\n### Start and stop webservice\r\n\r\n#### Start webservice\r\n\r\nThe starting point function are `ulfius_start_framework` or `ulfius_start_secure_framework`:\r\n\r\n```c\r\n/**\r\n * ulfius_start_framework\r\n * Initializes the framework and run the webservice based on the parameters given\r\n * return truze if no error\r\n * \r\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\r\n * return U_OK on success\r\n */\r\nint ulfius_start_framework(struct _u_instance * u_instance);\r\n\r\n/**\r\n * ulfius_start_secure_framework\r\n * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection\r\n * \r\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\r\n * key_pem:       private key for the server\r\n * cert_pem:      server certificate\r\n * return U_OK on success\r\n */\r\nint ulfius_start_secure_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem);\r\n```\r\n\r\nIn your program where you want to start the web server, simply execute the function `ulfius_start_framework(struct _u_instance * u_instance)` for a non-secure http connection or `ulfius_start_secure_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem)` for a secure https connection, using a valid private key and a valid corresponding server certificate, see openssl documentation for certificate generation. Those function accept the previously declared `instance` as first parameter. You can reuse the same callback function as much as you want for different endpoints. On success, these functions returns `U_OK`, otherwise an error code.\r\n\r\n#### Stop webservice\r\n\r\nTo stop the webservice, call the following function:\r\n\r\n```c\r\n/**\r\n * ulfius_stop_framework\r\n * \r\n * Stop the webservice\r\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\r\n * return U_OK on success\r\n */\r\nint ulfius_stop_framework(struct _u_instance * u_instance);\r\n```\r\n\r\n### Callback and Authentication functions\r\n\r\nThe authentication function is the function called for authentication purposes. Ulfius implements basic auth, the user and the password sent by the client are members of `struct _u_request` (see below). In this function, you can implement the authentication method you want by checking the user and password given. If the return value of the authentication function is `U_OK`, the authentication will pass and the callback function will be called then, if the return value is `U_ERROR_UNAUTHORIZED`, the response will be a 401 with the realm parameter given and the response body specified, if the return value is neither `U_OK` nor `U_ERROR_UNAUTHORIZED`, an error 500 will be sent to the client. Authentication functions are optional for endpoints.\r\n\r\nThe callback function is the function called when a user calls an endpoint managed by your webservice (as defined in your `struct _u_endpoint` list).\r\n\r\nThe authentication function and the callback function have the following signature:\r\n\r\n```c\r\nint (* auth_function)(const struct _u_request * request, // Input parameters (set by the framework)\r\n                      struct _u_response * response,     // Output parameters (set by the user)\r\n                      void * auth_data);\r\n\r\nint (* callback_function)(const struct _u_request * request, // Input parameters (set by the framework)\r\n                          struct _u_response * response,     // Output parameters (set by the user)\r\n                          void * user_data);\r\n```\r\n\r\nIn the authentication and callback functions definition, the variables `request` and `response` will be set by the framework, and the `auth_data` or `user_data` variable will be assigned to the user_data defined in your endpoint list definition.\r\n\r\nThe request variable is defined as:\r\n\r\n```c\r\n/**\r\n * \r\n * Structure of request parameters\r\n * \r\n * Contains request data\r\n * http_verb:                 http method (GET, POST, PUT, DELETE, etc.), use '*' to match all http methods\r\n * http_url:                  url used to call this callback function or full url to call when used in a ulfius_send_http_request\r\n * check_server_certificate:  do not check server certificate and hostname if false (default true), used by ulfius_send_http_request\r\n * client_address:            IP address of the client\r\n * auth_basic_user:           basic authtication username\r\n * auth_basic_password:       basic authtication password\r\n * map_url:                   map containing the url variables, both from the route and the ?key=value variables\r\n * map_header:                map containing the header variables\r\n * map_cookie:                map containing the cookie variables\r\n * map_post_body:             map containing the post body variables (if available)\r\n * json_body:                 json_t * object containing the json body (if available)\r\n * json_error:                stack allocated json_error_t if json body was not parsed (if available)\r\n * json_has_error:            true if the json body was not parsed by jansson (if available)\r\n * binary_body:               pointer to raw body\r\n * binary_body_length:        length of raw body\r\n * \r\n */\r\nstruct _u_request {\r\n  char *               http_verb;\r\n  char *               http_url;\r\n  int                  check_server_certificate;\r\n  struct sockaddr *    client_address;\r\n  char *               auth_basic_user;\r\n  char *               auth_basic_password;\r\n  struct _u_map *      map_url;\r\n  struct _u_map *      map_header;\r\n  struct _u_map *      map_cookie;\r\n  struct _u_map *      map_post_body;\r\n  json_t *             json_body;\r\n  json_error_t *       json_error;\r\n  int                  json_has_error;\r\n  void *               binary_body;\r\n  size_t               binary_body_length;\r\n};\r\n```\r\n\r\nThe response variable is defined as:\r\n\r\n```c\r\n/**\r\n * \r\n * Structure of response parameters\r\n * \r\n * Contains response data that must be set by the user\r\n * status:               HTTP status code (200, 404, 500, etc)\r\n * protocol:             HTTP Protocol sent\r\n * map_header:           map containing the header variables\r\n * nb_cookies:           number of cookies sent\r\n * map_cookie:           array of cookies sent\r\n * string_body:          a char * containing the raw body response\r\n * json_body:            a json_t * object containing the json response\r\n * binary_body:          a void * containing a raw binary content\r\n * binary_body_length:   the length of the binary_body\r\n * stream_callback:      callback function to stream data in response body\r\n * stream_callback_free: callback function to free data allocated for streaming\r\n * stream_size:          size of the streamed data (-1 if unknown)\r\n * stream_block_size:    size of each block to be streamed, set according to your system\r\n * stream_user_data:     user defined data that will be available in your callback stream functions\r\n * \r\n */\r\nstruct _u_response {\r\n  long               status;\r\n  char             * protocol;\r\n  struct _u_map    * map_header;\r\n  unsigned int       nb_cookies;\r\n  struct _u_cookie * map_cookie;\r\n  char             * string_body;\r\n  json_t           * json_body;\r\n  void             * binary_body;\r\n  unsigned int       binary_body_length;\r\n  int             (* stream_callback) (void * stream_user_data, uint64_t offset, char * out_buf, size_t max);\r\n  void            (* stream_callback_free) (void * stream_user_data);\r\n  size_t             stream_size;\r\n  unsigned int       stream_block_size;\r\n  void             * stream_user_data;\r\n};\r\n```\r\n\r\nIn the response variable set by the framework to the callback function, the structure is initialized with no data, except for the map_cookie which is set to the same key/values as the request element `map_cookie`.\r\n\r\nThe user must set the `string_body` or the `json_body` or the `binary_body` before the return statement, or no response body at all if no need. If a `string_body` is set, the `json_body` or the `binary_body` won't be tested. So to return a `json_body` object, you must leave `string_body` with a `NULL` value. Likewise, if a `json_body` is set, the `binary_body` won't be tested. Finally, if a `binary_body` is set, its size must be set to `binary_body_length`. Elements `string_body`, `binary_body` and `json_body` are free'd by the framework when the response has been sent  to the client, so you must use dynamically allocated values. If no status is set, status 200 will be sent to the client.\r\n\r\nSome functions are dedicated to handle the response:\r\n\r\n```c\r\n/**\r\n * ulfius_add_header_to_response\r\n * add a header to the response\r\n * return U_OK on success\r\n */\r\nint ulfius_add_header_to_response(struct _u_response * response, const char * key, const char * value);\r\n\r\n/**\r\n * ulfius_set_string_response\r\n * Add a string body to a response\r\n * body must end with a '\\0' character\r\n * return U_OK on success\r\n */\r\nint ulfius_set_string_response(struct _u_response * response, const uint status, const char * body);\r\n\r\n/**\r\n * ulfius_set_binary_response\r\n * Add a binary body to a response\r\n * return U_OK on success\r\n */\r\nint ulfius_set_binary_response(struct _u_response * response, const uint status, const char * body, const size_t length);\r\n\r\n/**\r\n * ulfius_set_json_response\r\n * Add a json_t body to a response\r\n * return U_OK on success\r\n */\r\nint ulfius_set_json_response(struct _u_response * response, const uint status, const json_t * body);\r\n\r\n/**\r\n * ulfius_set_empty_response\r\n * Set an empty response with only a status\r\n * return U_OK on success\r\n */\r\nint ulfius_set_empty_response(struct _u_response * response, const uint status);\r\n\r\n/**\r\n * ulfius_set_stream_response\r\n * Set an stream response with a status\r\n * return U_OK on success\r\n */\r\nint ulfius_set_stream_response(struct _u_response * response, \r\n                                const uint status,\r\n                                int (* stream_callback) (void * stream_user_data, uint64_t offset, char * out_buf, size_t max),\r\n                                void (* stream_callback_free) (void * stream_user_data),\r\n                                size_t stream_size,\r\n                                unsigned int stream_block_size,\r\n                                void * stream_user_data);\r\n```\r\n\r\nThe `jansson` api documentation is available at the following address: [Jansson documentation](https://jansson.readthedocs.org/).\r\n\r\nThe authentication function return value must be `U_OK` on authentication success, if the credentials are incorrect, you must return `U_ERROR_UNAUTHORIZED` to send an error 401 to the client, then, the body response will be sent to the client. All other returned value will send an error 500 to the client. If the authentication function return value is `U_OK`, the response body and status will be ignored as the one sent to the client will be the response sent by the callback function.\r\n\r\nThe callback function return value is `U_OK` on success. If the return value is other than `U_OK`, an error 500 response will be sent to the client.\r\n\r\nIn addition with manipulating the raw parameters of the structures, you can use the `_u_request` and `_u_response` structures by using specific functions designed to facilitate their use and memory management:\r\n\r\n```c\r\n/**\r\n * ulfius_init_request\r\n * Initialize a request structure by allocating inner elements\r\n * return U_OK on success\r\n */\r\nint ulfius_init_request(struct _u_request * request);\r\n\r\n/**\r\n * ulfius_clean_request\r\n * clean the specified request's inner elements\r\n * user must free the parent pointer if needed after clean\r\n * or use ulfius_clean_request_full\r\n * return U_OK on success\r\n */\r\nint ulfius_clean_request(struct _u_request * request);\r\n\r\n/**\r\n * ulfius_clean_request_full\r\n * clean the specified request and all its elements\r\n * return U_OK on success\r\n */\r\nint ulfius_clean_request_full(struct _u_request * request);\r\n\r\n/**\r\n * ulfius_init_response\r\n * Initialize a response structure by allocating inner elements\r\n * return U_OK on success\r\n */\r\nint ulfius_init_response(struct _u_response * response);\r\n\r\n/**\r\n * ulfius_clean_response\r\n * clean the specified response's inner elements\r\n * user must free the parent pointer if needed after clean\r\n * or use ulfius_clean_response_full\r\n * return U_OK on success\r\n */\r\nint ulfius_clean_response(struct _u_response * response);\r\n\r\n/**\r\n * ulfius_clean_response_full\r\n * clean the specified response and all its elements\r\n * return U_OK on success\r\n */\r\nint ulfius_clean_response_full(struct _u_response * response);\r\n\r\n/**\r\n * ulfius_copy_response\r\n * Copy the source response elements into the des response\r\n * return U_OK on success\r\n */\r\nint ulfius_copy_response(struct _u_response * dest, const struct _u_response * source);\r\n\r\n/**\r\n * ulfius_clean_cookie\r\n * clean the cookie's elements\r\n * return U_OK on success\r\n */\r\nint ulfius_clean_cookie(struct _u_cookie * cookie);\r\n\r\n/**\r\n * Copy the cookie source elements into dest elements\r\n * return U_OK on success\r\n */\r\nint ulfius_copy_cookie(struct _u_cookie * dest, const struct _u_cookie * source);\r\n\r\n/**\r\n * create a new request based on the source elements\r\n * returned value must be free'd\r\n */\r\nstruct _u_request * ulfius_duplicate_request(const struct _u_request * request);\r\n\r\n/**\r\n * create a new response based on the source elements\r\n * return value must be free'd\r\n */\r\nstruct _u_response * ulfius_duplicate_response(const struct _u_response * response);\r\n```\r\n\r\n### Memory management\r\n\r\nThe Ulfius framework will automatically free the variables referenced by the request and responses structures, so you must use dynamically allocated values for the response pointers.\r\n\r\n### Cookie management\r\n\r\nThe map_cookie structure will contain a set of key/values to set the cookies. You can use the function `ulfius_add_cookie_to_response` in your callback function to facilitate cookies management. This function is defined as:\r\n\r\n```c\r\n/**\r\n * ulfius_add_cookie_to_header\r\n * add a cookie to the cookie map\r\n * return U_OK on success\r\n */\r\nint ulfius_add_cookie_to_response(struct _u_response * response, const char * key, const char * value, const char * expires, const uint max_age, \r\n                                  const char * domain, const char * path, const int secure, const int http_only);\r\n```\r\n\r\n### File upload\r\n\r\nUlifius allows file upload to the server. Beware that an uploaded file will be stored in the request object in memory, so uploading large files may dramatically slow the application or even crash it, depending on your system. An uploaded file is stored in the `request->map_body` structure. You can use `u_map_get_length` to get the exact length of the file as it may not be a string format.\r\n\r\nIf you want to limit the size of a post parameter, if you want to limit the file size for example, set the value `struct _u_instance.max_post_param_size`. Files or post data exceeding this size will be truncated to the size `struct _u_instance.max_post_param_size`. If this parameter is 0, then no limit is set. Default value is 0.\r\n\r\nSee `examples/sheep_counter` for a file upload example.\r\n\r\n### Streaming data\r\n\r\nIf you need to stream data, i.e. send a variable and potentially large amount of data, you can define and use `stream_callback_function` in the `struct _u_response`.\r\n\r\nNot that if you stream data to the client, any data that was in the `response->*_body` will be ignored. You must at least set the function pointer `struct _u_response.stream_callback` to stream data. Set `stream_size` to -1 if you don't know the size of the data you need to send, like in audio stream for example. Set `stream_block_size` according to you system resources to avoid out of memory errors, also, set `stream_callback_free` with a pointer to a function that will free values allocated by your stream callback function, as a `close()` file for example, and finally, you can set `stream_user_data` to a pointer.\r\n\r\nYou can use the function `ulfius_set_stream_response` to set those parameters.\r\n\r\nThe prototype of the `stream_callback` function is the following:\r\n\r\n```c\r\nint stream_callback (void * stream_user_data, // Your predefined user_data\r\n                    uint64_t offset,          // the position of the current data to send\r\n                    char * out_buf,           // The output buffer to fill with data\r\n                    size_t max);              // the max size of data to be put in the out_buf\r\n```\r\n\r\nThe return value must be the size of the data put in `out_buf`.\r\n\r\nThis function will be recalled in loop as long as the client has the connection opened.\r\n\r\nIf you want to close the stream from the server side, return `ULFIUS_STREAM_END` in the `stream_callback` function. If you a problem occured, you can close the connection with a `ULFIUS_STREAM_ERROR` return value.\r\n\r\nWhile the `stream_callback_free` function is as simple as:\r\n\r\n```c\r\nvoid stream_callback_free (void * stream_user_data);\r\n```\r\n\r\nCheck the program `stream_example` in the example folder.\r\n\r\n### Character encoding\r\n\r\nYou may be careful with characters encoding if you use non UTF8 characters in your application or webservice, and especially if you use different encodings in the same application. Ulfius has not been fully tested in cases like that.\r\n\r\n### struct _u_map API\r\n\r\nThe `struct _u_map` is a simple key/value mapping API used in the requests and the response for setting parameters. The available functions to use this structure are:\r\n\r\n```c\r\n/**\r\n * initialize a struct _u_map\r\n * this function MUST be called after a declaration or allocation\r\n * return U_OK on success\r\n */\r\nint u_map_init(struct _u_map * map);\r\n\r\n/**\r\n * free the struct _u_map's inner components\r\n * return U_OK on success\r\n */\r\nint u_map_clean(struct _u_map * u_map);\r\n\r\n/**\r\n * free the struct _u_map and its components\r\n * return U_OK on success\r\n */\r\nint u_map_clean_full(struct _u_map * u_map);\r\n\r\n/**\r\n * free an enum return by functions u_map_enum_keys or u_map_enum_values\r\n * return U_OK on success\r\n */\r\nint u_map_clean_enum(char ** array);\r\n\r\n/**\r\n * returns an array containing all the keys in the struct _u_map\r\n * return an array of char * ending with a NULL element\r\n */\r\nconst char ** u_map_enum_keys(const struct _u_map * u_map);\r\n\r\n/**\r\n * returns an array containing all the values in the struct _u_map\r\n * return an array of char * ending with a NULL element\r\n */\r\nconst char ** u_map_enum_values(const struct _u_map * u_map);\r\n\r\n/**\r\n * return true if the sprcified u_map contains the specified key\r\n * false otherwise\r\n * search is case sensitive\r\n */\r\nint u_map_has_key(const struct _u_map * u_map, const char * key);\r\n\r\n/**\r\n * return true if the sprcified u_map contains the specified value\r\n * false otherwise\r\n * search is case sensitive\r\n */\r\nint u_map_has_value(const struct _u_map * u_map, const char * value);\r\n\r\n/**\r\n * return true if the sprcified u_map contains the specified value up until the specified length\r\n * false otherwise\r\n * search is case sensitive\r\n */\r\nint u_map_has_value_binary(const struct _u_map * u_map, const char * value, size_t length);\r\n\r\n/**\r\n * return true if the sprcified u_map contains the specified key\r\n * false otherwise\r\n * search is case insensitive\r\n */\r\nint u_map_has_key_case(const struct _u_map * u_map, const char * key);\r\n\r\n/**\r\n * return true if the sprcified u_map contains the specified value\r\n * false otherwise\r\n * search is case insensitive\r\n */\r\nint u_map_has_value_case(const struct _u_map * u_map, const char * value);\r\n\r\n/**\r\n * add the specified key/value pair into the specified u_map\r\n * if the u_map already contains a pair with the same key, replace the value\r\n * return U_OK on success\r\n */\r\nint u_map_put(struct _u_map * u_map, const char * key, const char * value);\r\n\r\n/**\r\n * add the specified key/binary value pair into the specified u_map\r\n * if the u_map already contains a pair with the same key,\r\n * replace the value at the specified offset with the specified length\r\n * return U_OK on success\r\n */\r\nint u_map_put_binary(struct _u_map * u_map, const char * key, const char * value, uint64_t offset, size_t length);\r\n\r\n/**\r\n * get the value length corresponding to the specified key in the u_map\r\n * return -1 if no match found\r\n * search is case sensitive\r\n */\r\nsize_t u_map_get_length(const struct _u_map * u_map, const const char * key);\r\n\r\n/**\r\n * get the value length corresponding to the specified key in the u_map\r\n * return -1 if no match found\r\n * search is case insensitive\r\n */\r\nsize_t u_map_get_case_length(const struct _u_map * u_map, const const char * key);\r\n\r\n/**\r\n * get the value corresponding to the specified key in the u_map\r\n * return NULL if no match found\r\n * search is case sensitive\r\n */\r\nconst char * u_map_get(const struct _u_map * u_map, const const char * key);\r\n\r\n/**\r\n * get the value corresponding to the specified key in the u_map\r\n * return NULL if no match found\r\n * search is case insensitive\r\n */\r\nconst char * u_map_get_case(const struct _u_map * u_map, const char * key);\r\n\r\n/**\r\n * remove an pair key/value that has the specified key\r\n * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise\r\n */\r\nint u_map_remove_from_key(struct _u_map * u_map, const char * key);\r\n\r\n/**\r\n * remove all pairs key/value that has the specified key (case insensitive search)\r\n * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise\r\n */\r\nint u_map_remove_from_key_case(struct _u_map * u_map, const char * key);\r\n\r\n/**\r\n * remove all pairs key/value that has the specified value\r\n * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise\r\n */\r\nint u_map_remove_from_value(struct _u_map * u_map, const char * value);\r\n\r\n/**\r\n * remove all pairs key/value that has the specified value (case insensitive search)\r\n * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise\r\n */\r\nint u_map_remove_from_value_case(struct _u_map * u_map, const char * value);\r\n\r\n/**\r\n * remove all pairs key/value that has the specified value up until the specified length\r\n * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise\r\n */\r\nint u_map_remove_from_value_binary(struct _u_map * u_map, const char * key, size_t length);\r\n\r\n/**\r\n * remove the pair key/value at the specified index\r\n * return U_OK on success, U_NOT_FOUND if index is out of bound, error otherwise\r\n */\r\nint u_map_remove_at(struct _u_map * u_map, const int index);\r\n\r\n/**\r\n * Create an exact copy of the specified struct _u_map\r\n * return a reference to the copy, NULL otherwise\r\n * returned value must be free'd after use\r\n */\r\nstruct _u_map * u_map_copy(const struct _u_map * source);\r\n\r\n/**\r\n * Return the number of key/values pair in the specified struct _u_map\r\n * Return -1 on error\r\n */\r\nint u_map_count(const struct _u_map * source);\r\n```\r\n\r\n### Send HTTP request API\r\n\r\nThe functions `int ulfius_send_http_request(const struct _u_request * request, struct _u_response * response)` and `int ulfius_send_http_streaming_request(const struct _u_request * request, struct _u_response * response, size_t (* write_body_function)(void * contents, size_t size, size_t nmemb, void * user_data), void * write_body_data)` are based on `libcurl` api.\r\n\r\nIt allows to send an http request with the parameters specified by the `_u_request` structure. Use the parameter `_u_request.http_url` to specify the distant url to call.\r\n\r\nYou can fill the maps in the `_u_request` structure with parameters, they will be used to build the request. Note that if you fill `_u_request.map_post_body` with parameters, the content-type `application/x-www-form-urlencoded` will be use to encode the data.\r\n\r\nThe response parameters is stored into the `_u_response` structure. If you specify NULL for the response structure, the http call will still be made but no response details will be returned. If you use `ulfius_send_http_request`, the response body will be stored in the parameter `response->*body*`, if you use `ulfius_send_http_streaming_request`, the response body will be available in the `write_body_function` specified in the call. The `ulfius_send_http_streaming_request` can be used for streaming data or large response.\r\n\r\nReturn value is `U_OK` on success.\r\n\r\nThis functions are defined as:\r\n\r\n```c\r\n/**\r\n * ulfius_send_http_request\r\n * Send a HTTP request and store the result into a _u_response\r\n * return U_OK on success\r\n */\r\nint ulfius_send_http_request(const struct _u_request * request, struct _u_response * response);\r\n\r\n/**\r\n * ulfius_send_http_streaming_request\r\n * Send a HTTP request and store the result into a _u_response\r\n * Except for the body which will be available using write_body_function in the write_body_data\r\n * return U_OK on success\r\n */\r\nint ulfius_send_http_streaming_request(const struct _u_request * request, \r\n                                       struct _u_response * response, \r\n                                       size_t (* write_body_function)(void * contents, \r\n                                                                      size_t size, \r\n                                                                      size_t nmemb, \r\n                                                                      void * user_data), \r\n                                       void * write_body_data);\r\n```\r\n\r\n### Send SMTP request API\r\n\r\nThe function `ulfius_send_smtp_email` is used to send emails using a smtp server. It is based on `libcurl` API.\r\n\r\nIt's used to send emails (without attached files) via a smtp server.\r\n\r\nThis function is defined as:\r\n\r\n```c\r\n/**\r\n * Send an email\r\n * host: smtp server host name\r\n * port: tcp port number (optional, 0 for default)\r\n * use_tls: true if the connection is tls secured\r\n * verify_certificate: true if you want to disable the certificate verification on a tls server\r\n * user: connection user name (optional, NULL: no user name)\r\n * password: connection password (optional, NULL: no password)\r\n * from: from address (mandatory)\r\n * to: to recipient address (mandatory)\r\n * cc: cc recipient address (optional, NULL: no cc)\r\n * bcc: bcc recipient address (optional, NULL: no bcc)\r\n * subject: email subject (mandatory)\r\n * mail_body: email body (mandatory)\r\n * return U_OK on success\r\n */\r\nint ulfius_send_smtp_email(const char * host, \r\n                           const int port, \r\n                           const int use_tls, \r\n                           const int verify_certificate, \r\n                           const char * user, \r\n                           const char * password, \r\n                           const char * from, \r\n                           const char * to, \r\n                           const char * cc, \r\n                           const char * bcc, \r\n                           const char * subject, \r\n                           const char * mail_body);\r\n```\r\n\r\n### Example source code\r\n\r\nExample programs are available to see the different functionalities available, see `example` folder for detailed sample source codes and documentation.\r\n\r\n### Questions, problems ?\r\n\r\nI'm open for questions and suggestions, feel free to open an issue or send a pull request if you feel like it!\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}