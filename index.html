<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Ulfius by babelouest</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Ulfius</h1>
        <h2>Web Framework for json REST API in C</h2>
        <a href="https://github.com/babelouest/ulfius" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="ulfius" class="anchor" href="#ulfius" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ulfius</h1>

<p>Web Framework for REST Applications in C.</p>

<p>Based on <a href="https://www.gnu.org/software/libmicrohttpd/">GNU Libmicrohttpd</a> for the backend web server, <a href="http://www.digip.org/jansson/">Jansson</a> for the json manipulation library, and <a href="http://curl.haxx.se/libcurl/">Libcurl</a> for the http/smtp client API.</p>

<p>Used to facilitate creation of web applications in C programs with a small memory footprint, as in embedded systems applications.</p>

<h2>
<a id="hello-world-example-application" class="anchor" href="#hello-world-example-application" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hello World! example application</h2>

<p>The source code of a hello world using Ulfius could be the following:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * test.c</span>
<span class="pl-c"> * Small Hello World! example</span>
<span class="pl-c"> * to compile with gcc, run the following command</span>
<span class="pl-c"> * gcc -o test test.c -lulfius</span>
<span class="pl-c"> */</span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ulfius.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

#<span class="pl-k">define</span> <span class="pl-en">PORT</span> <span class="pl-c1">8080</span>

<span class="pl-c">/**</span>
<span class="pl-c"> * Callback function for the web application on /helloworld url call</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">callback_hello_world</span> (<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-k">struct</span> _u_response * response, <span class="pl-k">void</span> * user_data) {
  <span class="pl-c1">ulfius_set_string_response</span>(response, <span class="pl-c1">200</span>, <span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>);
  <span class="pl-k">return</span> U_OK;
}

<span class="pl-c">/**</span>
<span class="pl-c"> * main function</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {
  <span class="pl-k">struct</span> _u_instance instance;

  <span class="pl-c">// Initialize instance with the port number</span>
  <span class="pl-k">if</span> (<span class="pl-c1">ulfius_init_instance</span>(&amp;instance, PORT, <span class="pl-c1">NULL</span>) != U_OK) {
    <span class="pl-c1">fprintf</span>(stderr, <span class="pl-s"><span class="pl-pds">"</span>Error ulfius_init_instance, abort<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
    <span class="pl-k">return</span>(<span class="pl-c1">1</span>);
  }

  <span class="pl-c">// Endpoint list declaration</span>
  <span class="pl-c1">ulfius_add_endpoint_by_val</span>(&amp;instance, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>/helloworld<span class="pl-pds">"</span></span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, &amp;callback_hello_world, <span class="pl-c1">NULL</span>);

  <span class="pl-c">// Start the framework</span>
  <span class="pl-k">if</span> (<span class="pl-c1">ulfius_start_framework</span>(&amp;instance) == U_OK) {
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Start framework on port <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, instance.<span class="pl-smi">port</span>);

    <span class="pl-c">// Wait for the user to press &lt;enter&gt; on the console to quit the application</span>
    <span class="pl-c1">getchar</span>();
  } <span class="pl-k">else</span> {
    <span class="pl-c1">fprintf</span>(stderr, <span class="pl-s"><span class="pl-pds">"</span>Error starting framework<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
  }
  <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>End framework<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);

  <span class="pl-c1">ulfius_stop_framework</span>(&amp;instance);
  <span class="pl-c1">ulfius_clean_instance</span>(&amp;instance);

  <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<h1>
<a id="prerequisites" class="anchor" href="#prerequisites" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h1>

<h2>
<a id="external-dependencies" class="anchor" href="#external-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>External dependencies</h2>

<p>To install the external dependencies, for Debian based distributions (Debian, Ubuntu, Raspbian, etc.), run as root:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-c"># apt-get install libmicrohttpd-dev libjansson-dev libcurl4-gnutls-dev</span></pre></div>

<h3>
<a id="note" class="anchor" href="#note" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Note</h3>

<p>I write libcurl4-gnutls-dev for the example, but any <code>libcurl*-dev</code> library should be sufficent, depending on your needs and configuration.</p>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h1>

<p>Download Ulfius source code from Github, get the submodules, compile and install:</p>

<div class="highlight highlight-source-shell"><pre>$ git clone https://github.com/babelouest/ulfius.git
$ <span class="pl-c1">cd</span> ulfius/
$ git submodule update --init
$ make
$ sudo make install</pre></div>

<p>By default, the shared libraries and the header files will be installed in the <code>/usr/local</code> location. To change this setting, you can modify the <code>PREFIX</code> value in the <code>src/Makefile</code>, <code>lib/orcania/Makefile</code> and <code>lib/yder/src/Makefile</code> files.</p>

<h2>
<a id="libcurl-older-than-720" class="anchor" href="#libcurl-older-than-720" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>libcurl older than 7.20</h2>

<p>If you use old version of liburl, as in Centos 6.5 for example, <code>ulfius_send_smtp_email</code> won't be available due to libcurl options problems. In this case, uncomment the following line in the file <code>src/Makefile</code>:</p>

<div class="highlight highlight-source-makefile"><pre><span class="pl-c">#SMTPFLAGS=-DULFIUS_IGNORE_SMTP</span></pre></div>

<p>This will disable <code>ulfius_send_smtp_email</code> during the compilation.</p>

<h1>
<a id="api-documentation" class="anchor" href="#api-documentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Documentation</h1>

<h2>
<a id="header-file" class="anchor" href="#header-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Header file</h2>

<p>Include file <code>ulfius.h</code> in your source file:</p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ulfius.h<span class="pl-pds">&gt;</span></span></pre></div>

<p>On your linker command, add ulfius as a dependency library, e.g. <code>-lulfius</code> for gcc.</p>

<h2>
<a id="api-documentation-1" class="anchor" href="#api-documentation-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Documentation</h2>

<h3>
<a id="return-values" class="anchor" href="#return-values" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Return values</h3>

<p>When specified, some functions return <code>U_OK</code> on success, and other values otherwise. <code>U_OK</code> is 0, other values are non-0 values. The defined return value list is the following:</p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">define</span> <span class="pl-en">U_OK</span>                 <span class="pl-c1">0</span> <span class="pl-c">// No error</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR</span>              <span class="pl-c1">1</span> <span class="pl-c">// Error</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_MEMORY</span>       <span class="pl-c1">2</span> <span class="pl-c">// Error in memory allocation</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_PARAMS</span>       <span class="pl-c1">3</span> <span class="pl-c">// Error in input parameters</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_LIBMHD</span>       <span class="pl-c1">4</span> <span class="pl-c">// Error in libmicrohttpd execution</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_LIBCURL</span>      <span class="pl-c1">5</span> <span class="pl-c">// Error in libcurl execution</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_NOT_FOUND</span>    <span class="pl-c1">6</span> <span class="pl-c">// Something was not found</span>
#<span class="pl-k">define</span> <span class="pl-en">U_ERROR_UNAUTHORIZED</span> <span class="pl-c1">7</span> <span class="pl-c">// No authorization given</span></pre></div>

<h3>
<a id="initialization" class="anchor" href="#initialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Initialization</h3>

<p>When initialized, Ulfius runs a thread in background that will listen to the specified port and dispatch the calls to the specified functions. Ulfius allows adding and removing new endpoints during the instance execution.</p>

<p>To run a webservice, you must initialize a <code>struct _u_instance</code> and add your endpoints.</p>

<p>The <code>struct _u_instance</code> is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Structure of an instance</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Contains the needed data for an ulfius instance to work</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * mhd_daemon:            pointer to the libmicrohttpd daemon</span>
<span class="pl-c"> * status:                status of the current instance, status are U_STATUS_STOP, U_STATUS_RUNNING or U_STATUS_ERROR</span>
<span class="pl-c"> * port:                  port number to listen to</span>
<span class="pl-c"> * bind_address:          ip address to listen to (optional)</span>
<span class="pl-c"> * nb_endpoints:          Number of available endpoints</span>
<span class="pl-c"> * endpoint_list:         List of available endpoints</span>
<span class="pl-c"> * default_endpoint:      Default endpoint if no other endpoint match the current url</span>
<span class="pl-c"> * default_headers:       Default headers that will be added to all response-&gt;map_header</span>
<span class="pl-c"> * default_auth_function: Default callback function used for authentication (optional)</span>
<span class="pl-c"> *                        a pointer to a function used to check the client credentials</span>
<span class="pl-c"> *                        this function will be called prior to the callback function. If default_auth_function returned value is U_OK,</span>
<span class="pl-c"> *                        then the callback function will be called after. If default_auth_function is not U_OK, response status send will be</span>
<span class="pl-c"> *                        401 (Unauthorized), and callback_function will be skipped</span>
<span class="pl-c"> *                        If an endpoint already has a auth_callback set, the default_auth_function will not be called</span>
<span class="pl-c"> *                        but the auth_callback function of the endpoint will</span>
<span class="pl-c"> * default_auth_data:     a pointer to a data or a structure that will be available in auth_function</span>
<span class="pl-c"> * default_auth_realm:    realm value for authentication</span>
<span class="pl-c"> * max_post_param_size:   maximum size for a post parameter, 0 means no limit, default 0</span>
<span class="pl-c"> * max_post_body_size:    maximum size for the entire post body, 0 means no limit, default 0</span>
<span class="pl-c"> * </span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_instance {
  <span class="pl-k">struct</span> MHD_Daemon          *  mhd_daemon;
  <span class="pl-k">int</span>                           status;
  <span class="pl-k">int</span>                           port;
  <span class="pl-k">struct</span> sockaddr_in          * bind_address;
  <span class="pl-k">int</span>                           nb_endpoints;
  <span class="pl-k">struct</span> _u_endpoint          * endpoint_list;
  <span class="pl-k">struct</span> _u_endpoint          * default_endpoint;
  <span class="pl-k">struct</span> _u_map               * default_headers;
  <span class="pl-c1">int</span> (* default_auth_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-c">// Input parameters (set by the framework)</span>
                                <span class="pl-k">struct</span> _u_response * response,     <span class="pl-c">// Output parameters (set by the user)</span>
                                <span class="pl-k">void</span> * auth_data);
  <span class="pl-k">void</span> *                        default_auth_data;
  <span class="pl-k">char</span> *                        default_auth_realm;
  <span class="pl-c1">size_t</span>                        max_post_param_size;
  <span class="pl-c1">size_t</span>                        max_post_body_size;
};</pre></div>

<p>In the <code>struct _u_instance</code> structure, the element <code>port</code> must be set to the port number you want to listen to, the element <code>bind_address</code> is used if you want to listen only to a specific IP address. The element <code>mhd_daemon</code> is used by the framework, don't modify it.</p>

<p>You can use the functions <code>ulfius_init_instance</code> and <code>ulfius_clean_instance</code> to facilitate the manipulation of the structure:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_init_instance</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Initialize a struct _u_instance * with default values</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_init_instance</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">int</span> port, <span class="pl-k">struct</span> sockaddr_in * bind_address);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_instance</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Clean memory allocated by a struct _u_instance *</span>
<span class="pl-c"> */</span>
<span class="pl-k">void</span> <span class="pl-en">ulfius_clean_instance</span>(<span class="pl-k">struct</span> _u_instance * u_instance);</pre></div>

<p>The <code>struct _u_endpoint</code> is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Structure of an endpoint</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Contains all informations needed for an endpoint</span>
<span class="pl-c"> * http_method:       http verb (GET, POST, PUT, etc.) in upper case</span>
<span class="pl-c"> * url_prefix:        prefix for the url (optional)</span>
<span class="pl-c"> * url_format:        string used to define the endpoint format</span>
<span class="pl-c"> *                    separate words with /</span>
<span class="pl-c"> *                    to define a variable in the url, prefix it with @ or :</span>
<span class="pl-c"> *                    example: /test/resource/:name/elements</span>
<span class="pl-c"> *                    on an url_format that ends with '*', the rest of the url will not be tested</span>
<span class="pl-c"> * auth_function:     a pointer to a function used to check the client credentials he sent (optional)</span>
<span class="pl-c"> *                    this function will be called prior to the callback function. If auth_function returned value is U_OK,</span>
<span class="pl-c"> *                    then the callback function will be called after. If auth_function is not U_OK, response status send will be</span>
<span class="pl-c"> *                    401 (Unauthorized), and callback_function will be skipped</span>
<span class="pl-c"> * auth_data:         a pointer to a data or a structure that will be available in auth_function</span>
<span class="pl-c"> * auth_realm:        realm value for authentication</span>
<span class="pl-c"> * callback_function: a pointer to a function that will be executed each time the endpoint is called</span>
<span class="pl-c"> *                    you must declare the function as described.</span>
<span class="pl-c"> * user_data:         a pointer to a data or a structure that will be available in callback_function</span>
<span class="pl-c"> * </span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_endpoint {
  <span class="pl-k">char</span> * http_method;
  <span class="pl-k">char</span> * url_prefix;
  <span class="pl-k">char</span> * url_format;
  <span class="pl-c1">int</span> (* auth_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-c">// Input parameters (set by the framework)</span>
                        <span class="pl-k">struct</span> _u_response * response,     <span class="pl-c">// Output parameters (set by the user)</span>
                        <span class="pl-k">void</span> * user_data);
  <span class="pl-k">void</span> * auth_data;
  <span class="pl-k">char</span> * auth_realm;
  <span class="pl-c1">int</span> (* callback_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-c">// Input parameters (set by the framework)</span>
                            <span class="pl-k">struct</span> _u_response * response,     <span class="pl-c">// Output parameters (set by the user)</span>
                            <span class="pl-k">void</span> * user_data);
  <span class="pl-k">void</span> * user_data;
};</pre></div>

<p>Some functions help you facilitate endpoints manipulation:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * Add a struct _u_endpoint * to the specified u_instance</span>
<span class="pl-c"> * Can be done during the execution of the webservice for injection</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * u_endpoint: pointer to a struct _u_endpoint that will be copied in the u_instance endpoint_list</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_add_endpoint</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">const</span> <span class="pl-k">struct</span> _u_endpoint * u_endpoint);

<span class="pl-c">/**</span>
<span class="pl-c"> * Add a struct _u_endpoint * to the specified u_instance with its values specified</span>
<span class="pl-c"> * Can be done during the execution of the webservice for injection</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * http_method:       http verb (GET, POST, PUT, etc.) in upper case</span>
<span class="pl-c"> * url_prefix:        prefix for the url (optional)</span>
<span class="pl-c"> * url_format:        string used to define the endpoint format</span>
<span class="pl-c"> *                    separate words with /</span>
<span class="pl-c"> *                    to define a variable in the url, prefix it with @ or :</span>
<span class="pl-c"> *                    example: /test/resource/:name/elements</span>
<span class="pl-c"> *                    on an url_format that ends with '*', the rest of the url will not be tested</span>
<span class="pl-c"> * auth_function:     a pointer to a function that will be executed prior to the callback for authentication</span>
<span class="pl-c"> *                    you must declare the function as described.</span>
<span class="pl-c"> * auth_data:         a pointer to a data or a structure that will be available in auth_function</span>
<span class="pl-c"> * auth_realm:        realm value for authentication</span>
<span class="pl-c"> * callback_function: a pointer to a function that will be executed each time the endpoint is called</span>
<span class="pl-c"> *                    you must declare the function as described.</span>
<span class="pl-c"> * user_data:         a pointer to a data or a structure that will be available in callback_function</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_add_endpoint_by_val</span>(<span class="pl-k">struct</span> _u_instance * u_instance,
                               <span class="pl-k">const</span> <span class="pl-k">char</span> * http_method,
                               <span class="pl-k">const</span> <span class="pl-k">char</span> * url_prefix,
                               <span class="pl-k">const</span> <span class="pl-k">char</span> * url_format,
                               <span class="pl-en">int</span> (* auth_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request,
                                                     <span class="pl-k">struct</span> _u_response * response,
                                                     <span class="pl-k">void</span> * auth_data),
                               void * auth_data,
                               char * auth_realm,
                               int (* callback_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request,
                                                         <span class="pl-k">struct</span> _u_response * response,
                                                         <span class="pl-k">void</span> * user_data),
                               void * user_data);

<span class="pl-c">/**</span>
<span class="pl-c"> * Add a struct _u_endpoint * list to the specified u_instance</span>
<span class="pl-c"> * Can be done during the execution of the webservice for injection</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * u_endpoint_list: pointer to an array of struct _u_endpoint ending with a ulfius_empty_endpoint() that will be copied in the u_instance endpoint_list</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_add_endpoint_list</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">const</span> <span class="pl-k">struct</span> _u_endpoint ** u_endpoint_list);

<span class="pl-c">/**</span>
<span class="pl-c"> * Remove a struct _u_endpoint * from the specified u_instance</span>
<span class="pl-c"> * Can be done during the execution of the webservice for injection</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * u_endpoint: pointer to a struct _u_endpoint that will be removed in the u_instance endpoint_list</span>
<span class="pl-c"> * The parameters _u_endpoint.http_method, _u_endpoint.url_prefix and _u_endpoint.url_format are strictly compared for the match</span>
<span class="pl-c"> * If no endpoint is found, return U_ERROR_NOT_FOUND</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_remove_endpoint</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">const</span> <span class="pl-k">struct</span> _u_endpoint * u_endpoint);

<span class="pl-c">/**</span>
<span class="pl-c"> * Remove a struct _u_endpoint * from the specified u_instance</span>
<span class="pl-c"> * using the specified values used to identify an endpoint</span>
<span class="pl-c"> * Can be done during the execution of the webservice for injection</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * http_method: http_method used by the endpoint</span>
<span class="pl-c"> * url_prefix: url_prefix used by the endpoint</span>
<span class="pl-c"> * url_format: url_format used by the endpoint</span>
<span class="pl-c"> * The parameters _u_endpoint.http_method, _u_endpoint.url_prefix and _u_endpoint.url_format are strictly compared for the match</span>
<span class="pl-c"> * If no endpoint is found, return U_ERROR_NOT_FOUND</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_remove_endpoint_by_val</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">const</span> <span class="pl-k">char</span> * http_method, <span class="pl-k">const</span> <span class="pl-k">char</span> * url_prefix, <span class="pl-k">const</span> <span class="pl-k">char</span> * url_format);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_default_callback_function</span>
<span class="pl-c"> * Set the default callback function</span>
<span class="pl-c"> * This callback will be called if no endpoint match the url called</span>
<span class="pl-c"> * callback_function: a pointer to a function that will be executed each time the endpoint is called</span>
<span class="pl-c"> *                    you must declare the function as described.</span>
<span class="pl-c"> * user_data:         a pointer to a data or a structure that will be available in the callback function</span>
<span class="pl-c"> * to remove a default callback function, call ulfius_set_default_callback_function with NULL parameter for callback_function</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_default_callback_function</span>(<span class="pl-k">struct</span> _u_instance * u_instance,
                                         <span class="pl-en">int</span> (* callback_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-k">struct</span> _u_response * response, <span class="pl-k">void</span> * user_data),
                                         void * user_data);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_default_auth_function</span>
<span class="pl-c"> * Set the default authentication function</span>
<span class="pl-c"> * This authentication function will be called if there is no auth_function attached to the endpoint</span>
<span class="pl-c"> * u_instance: pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * auth_function:     a pointer to a function that will be executed prior to the callback for authentication</span>
<span class="pl-c"> *                    you must declare the function as described.</span>
<span class="pl-c"> * auth_data:         a pointer to a data or a structure that will be available in auth_function</span>
<span class="pl-c"> * auth_realm:        realm value for authentication</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_default_auth_function</span>(<span class="pl-k">struct</span> _u_instance * u_instance,
                                         <span class="pl-en">int</span> (* default_auth_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-k">struct</span> _u_response * response, <span class="pl-k">void</span> * auth_data),
                                         void * default_auth_data,
                                         <span class="pl-k">const</span> char * default_auth_realm);</pre></div>

<p>HTTP Method can be an existing or not existing method, or * for any method, you must specify a url_prefix, a url_format or both, callback_function is mandatory, user_data is optional.</p>

<p>Your <code>struct _u_endpoint</code> array <strong>MUST</strong> end with an empty <code>struct _u_endpoint</code>.</p>

<p>You can manually declare an endpoint or use the dedicated functions as <code>int ulfius_add_endpoint</code> or <code>int ulfius_add_endpoint_by_val</code>.</p>

<p>If you manipulate the attribute <code>u_instance.endpoint_list</code>, you must end the list with an empty endpoint (see <code>const struct _u_endpoint * ulfius_empty_endpoint()</code>), and you must set the attribute <code>u_instance.nb_endpoints</code> accordingly. Also, you must use dynamically allocated values for attributes <code>http_method</code>, <code>url_prefix</code> and <code>url_format</code>.</p>

<p>Please note that each time a call is made to the webservice, endpoints will be tested in the same order. On the first matching endpoint, the other ones won't be tested. So be careful on your endpoints declaration order. If no endpoint is found, an error 404 is raised, except if you set a default endpoint. If you set a default endpoint with <code>ulfius_set_default_callback_function</code>, the default callback function will be run if no endpoint match the current url.</p>

<p>For example, if you declare the following endpoints in that order:</p>

<pre><code>/test/*
/test/test1
/test/test2
</code></pre>

<p>the last 2 will never be reached because the first one will always be a match for the urls <code>/test/test1</code> and <code>/test/test2</code>.</p>

<h3>
<a id="start-and-stop-webservice" class="anchor" href="#start-and-stop-webservice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Start and stop webservice</h3>

<h4>
<a id="start-webservice" class="anchor" href="#start-webservice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Start webservice</h4>

<p>The starting point function are <code>ulfius_start_framework</code> or <code>ulfius_start_secure_framework</code>:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_start_framework</span>
<span class="pl-c"> * Initializes the framework and run the webservice based on the parameters given</span>
<span class="pl-c"> * return truze if no error</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * u_instance:    pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_start_framework</span>(<span class="pl-k">struct</span> _u_instance * u_instance);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_start_secure_framework</span>
<span class="pl-c"> * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * u_instance:    pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * key_pem:       private key for the server</span>
<span class="pl-c"> * cert_pem:      server certificate</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_start_secure_framework</span>(<span class="pl-k">struct</span> _u_instance * u_instance, <span class="pl-k">const</span> <span class="pl-k">char</span> * key_pem, <span class="pl-k">const</span> <span class="pl-k">char</span> * cert_pem);</pre></div>

<p>In your program where you want to start the web server, simply execute the function <code>ulfius_start_framework(struct _u_instance * u_instance)</code> for a non-secure http connection or <code>ulfius_start_secure_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem)</code> for a secure https connection, using a valid private key and a valid corresponding server certificate, see openssl documentation for certificate generation. Those function accept the previously declared <code>instance</code> as first parameter. You can reuse the same callback function as much as you want for different endpoints. On success, these functions returns <code>U_OK</code>, otherwise an error code.</p>

<h4>
<a id="stop-webservice" class="anchor" href="#stop-webservice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stop webservice</h4>

<p>To stop the webservice, call the following function:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_stop_framework</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Stop the webservice</span>
<span class="pl-c"> * u_instance:    pointer to a struct _u_instance that describe its port and bind address</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_stop_framework</span>(<span class="pl-k">struct</span> _u_instance * u_instance);</pre></div>

<h3>
<a id="callback-and-authentication-functions" class="anchor" href="#callback-and-authentication-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Callback and Authentication functions</h3>

<p>The authentication function is the function called for authentication purposes. Ulfius implements basic auth, the user and the password sent by the client are members of <code>struct _u_request</code> (see below). In this function, you can implement the authentication method you want by checking the user and password given. If the return value of the authentication function is <code>U_OK</code>, the authentication will pass and the callback function will be called then, if the return value is <code>U_ERROR_UNAUTHORIZED</code>, the response will be a 401 with the realm parameter given and the response body specified, if the return value is neither <code>U_OK</code> nor <code>U_ERROR_UNAUTHORIZED</code>, an error 500 will be sent to the client. Authentication functions are optional for endpoints.</p>

<p>The callback function is the function called when a user calls an endpoint managed by your webservice (as defined in your <code>struct _u_endpoint</code> list).</p>

<p>The authentication function and the callback function have the following signature:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> (* auth_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-c">// Input parameters (set by the framework)</span>
                      <span class="pl-k">struct</span> _u_response * response,     <span class="pl-c">// Output parameters (set by the user)</span>
                      <span class="pl-k">void</span> * auth_data);

<span class="pl-k">int</span> (* callback_function)(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-c">// Input parameters (set by the framework)</span>
                          <span class="pl-k">struct</span> _u_response * response,     <span class="pl-c">// Output parameters (set by the user)</span>
                          <span class="pl-k">void</span> * user_data);</pre></div>

<p>In the authentication and callback functions definition, the variables <code>request</code> and <code>response</code> will be set by the framework, and the <code>auth_data</code> or <code>user_data</code> variable will be assigned to the user_data defined in your endpoint list definition.</p>

<p>The request variable is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Structure of request parameters</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Contains request data</span>
<span class="pl-c"> * http_verb:                 http method (GET, POST, PUT, DELETE, etc.), use '*' to match all http methods</span>
<span class="pl-c"> * http_url:                  url used to call this callback function or full url to call when used in a ulfius_send_http_request</span>
<span class="pl-c"> * check_server_certificate:  do not check server certificate and hostname if false (default true), used by ulfius_send_http_request</span>
<span class="pl-c"> * client_address:            IP address of the client</span>
<span class="pl-c"> * auth_basic_user:           basic authtication username</span>
<span class="pl-c"> * auth_basic_password:       basic authtication password</span>
<span class="pl-c"> * map_url:                   map containing the url variables, both from the route and the ?key=value variables</span>
<span class="pl-c"> * map_header:                map containing the header variables</span>
<span class="pl-c"> * map_cookie:                map containing the cookie variables</span>
<span class="pl-c"> * map_post_body:             map containing the post body variables (if available)</span>
<span class="pl-c"> * json_body:                 json_t * object containing the json body (if available)</span>
<span class="pl-c"> * json_error:                stack allocated json_error_t if json body was not parsed (if available)</span>
<span class="pl-c"> * json_has_error:            true if the json body was not parsed by jansson (if available)</span>
<span class="pl-c"> * binary_body:               pointer to raw body</span>
<span class="pl-c"> * binary_body_length:        length of raw body</span>
<span class="pl-c"> * </span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_request {
  <span class="pl-k">char</span> *               http_verb;
  <span class="pl-k">char</span> *               http_url;
  <span class="pl-k">int</span>                  check_server_certificate;
  <span class="pl-k">struct</span> sockaddr *    client_address;
  <span class="pl-k">char</span> *               auth_basic_user;
  <span class="pl-k">char</span> *               auth_basic_password;
  <span class="pl-k">struct</span> _u_map *      map_url;
  <span class="pl-k">struct</span> _u_map *      map_header;
  <span class="pl-k">struct</span> _u_map *      map_cookie;
  <span class="pl-k">struct</span> _u_map *      map_post_body;
  <span class="pl-c1">json_t</span> *             json_body;
  <span class="pl-c1">json_error_t</span> *       json_error;
  <span class="pl-k">int</span>                  json_has_error;
  <span class="pl-k">void</span> *               binary_body;
  <span class="pl-c1">size_t</span>               binary_body_length;
};</pre></div>

<p>The response variable is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Structure of response parameters</span>
<span class="pl-c"> * </span>
<span class="pl-c"> * Contains response data that must be set by the user</span>
<span class="pl-c"> * status:               HTTP status code (200, 404, 500, etc)</span>
<span class="pl-c"> * protocol:             HTTP Protocol sent</span>
<span class="pl-c"> * map_header:           map containing the header variables</span>
<span class="pl-c"> * nb_cookies:           number of cookies sent</span>
<span class="pl-c"> * map_cookie:           array of cookies sent</span>
<span class="pl-c"> * string_body:          a char * containing the raw body response</span>
<span class="pl-c"> * json_body:            a json_t * object containing the json response</span>
<span class="pl-c"> * binary_body:          a void * containing a raw binary content</span>
<span class="pl-c"> * binary_body_length:   the length of the binary_body</span>
<span class="pl-c"> * stream_callback:      callback function to stream data in response body</span>
<span class="pl-c"> * stream_callback_free: callback function to free data allocated for streaming</span>
<span class="pl-c"> * stream_size:          size of the streamed data (-1 if unknown)</span>
<span class="pl-c"> * stream_block_size:    size of each block to be streamed, set according to your system</span>
<span class="pl-c"> * stream_user_data:     user defined data that will be available in your callback stream functions</span>
<span class="pl-c"> * </span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_response {
  <span class="pl-k">long</span>               status;
  <span class="pl-k">char</span>             * protocol;
  <span class="pl-k">struct</span> _u_map    * map_header;
  <span class="pl-k">unsigned</span> <span class="pl-k">int</span>       nb_cookies;
  <span class="pl-k">struct</span> _u_cookie * map_cookie;
  <span class="pl-k">char</span>             * string_body;
  <span class="pl-c1">json_t</span>           * json_body;
  <span class="pl-k">void</span>             * binary_body;
  <span class="pl-k">unsigned</span> <span class="pl-k">int</span>       binary_body_length;
  <span class="pl-c1">int</span>             (* stream_callback) (<span class="pl-k">void</span> * stream_user_data, <span class="pl-c1">uint64_t</span> offset, <span class="pl-k">char</span> * out_buf, <span class="pl-c1">size_t</span> max);
  <span class="pl-c1">void</span>            (* stream_callback_free) (<span class="pl-k">void</span> * stream_user_data);
  <span class="pl-c1">size_t</span>             stream_size;
  <span class="pl-k">unsigned</span> <span class="pl-k">int</span>       stream_block_size;
  <span class="pl-k">void</span>             * stream_user_data;
};</pre></div>

<p>In the response variable set by the framework to the callback function, the structure is initialized with no data, except for the map_cookie which is set to the same key/values as the request element <code>map_cookie</code>.</p>

<p>The user must set the <code>string_body</code> or the <code>json_body</code> or the <code>binary_body</code> before the return statement, or no response body at all if no need. If a <code>string_body</code> is set, the <code>json_body</code> or the <code>binary_body</code> won't be tested. So to return a <code>json_body</code> object, you must leave <code>string_body</code> with a <code>NULL</code> value. Likewise, if a <code>json_body</code> is set, the <code>binary_body</code> won't be tested. Finally, if a <code>binary_body</code> is set, its size must be set to <code>binary_body_length</code>. Elements <code>string_body</code>, <code>binary_body</code> and <code>json_body</code> are free'd by the framework when the response has been sent  to the client, so you must use dynamically allocated values. If no status is set, status 200 will be sent to the client.</p>

<p>Some functions are dedicated to handle the response:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_add_header_to_response</span>
<span class="pl-c"> * add a header to the response</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_add_header_to_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-k">char</span> * key, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_string_response</span>
<span class="pl-c"> * Add a string body to a response</span>
<span class="pl-c"> * body must end with a '\0' character</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_string_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-c1">uint</span> status, <span class="pl-k">const</span> <span class="pl-k">char</span> * body);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_binary_response</span>
<span class="pl-c"> * Add a binary body to a response</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_binary_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-c1">uint</span> status, <span class="pl-k">const</span> <span class="pl-k">char</span> * body, <span class="pl-k">const</span> <span class="pl-c1">size_t</span> length);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_json_response</span>
<span class="pl-c"> * Add a json_t body to a response</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_json_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-c1">uint</span> status, <span class="pl-k">const</span> <span class="pl-c1">json_t</span> * body);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_empty_response</span>
<span class="pl-c"> * Set an empty response with only a status</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_empty_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-c1">uint</span> status);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_set_stream_response</span>
<span class="pl-c"> * Set an stream response with a status</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_set_stream_response</span>(<span class="pl-k">struct</span> _u_response * response, 
                                <span class="pl-k">const</span> <span class="pl-c1">uint</span> status,
                                <span class="pl-en">int</span> (* stream_callback) (<span class="pl-k">void</span> * stream_user_data, <span class="pl-c1">uint64_t</span> offset, <span class="pl-k">char</span> * out_buf, <span class="pl-c1">size_t</span> max),
                                void (* stream_callback_free) (<span class="pl-k">void</span> * stream_user_data),
                                size_t stream_size,
                                unsigned int stream_block_size,
                                void * stream_user_data);</pre></div>

<p>The <code>jansson</code> api documentation is available at the following address: <a href="https://jansson.readthedocs.org/">Jansson documentation</a>.</p>

<p>The authentication function return value must be <code>U_OK</code> on authentication success, if the credentials are incorrect, you must return <code>U_ERROR_UNAUTHORIZED</code> to send an error 401 to the client, then, the body response will be sent to the client. All other returned value will send an error 500 to the client. If the authentication function return value is <code>U_OK</code>, the response body and status will be ignored as the one sent to the client will be the response sent by the callback function.</p>

<p>The callback function return value is <code>U_OK</code> on success. If the return value is other than <code>U_OK</code>, an error 500 response will be sent to the client.</p>

<p>In addition with manipulating the raw parameters of the structures, you can use the <code>_u_request</code> and <code>_u_response</code> structures by using specific functions designed to facilitate their use and memory management:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_init_request</span>
<span class="pl-c"> * Initialize a request structure by allocating inner elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_init_request</span>(<span class="pl-k">struct</span> _u_request * request);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_request</span>
<span class="pl-c"> * clean the specified request's inner elements</span>
<span class="pl-c"> * user must free the parent pointer if needed after clean</span>
<span class="pl-c"> * or use ulfius_clean_request_full</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_clean_request</span>(<span class="pl-k">struct</span> _u_request * request);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_request_full</span>
<span class="pl-c"> * clean the specified request and all its elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_clean_request_full</span>(<span class="pl-k">struct</span> _u_request * request);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_init_response</span>
<span class="pl-c"> * Initialize a response structure by allocating inner elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_init_response</span>(<span class="pl-k">struct</span> _u_response * response);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_response</span>
<span class="pl-c"> * clean the specified response's inner elements</span>
<span class="pl-c"> * user must free the parent pointer if needed after clean</span>
<span class="pl-c"> * or use ulfius_clean_response_full</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_clean_response</span>(<span class="pl-k">struct</span> _u_response * response);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_response_full</span>
<span class="pl-c"> * clean the specified response and all its elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_clean_response_full</span>(<span class="pl-k">struct</span> _u_response * response);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_copy_response</span>
<span class="pl-c"> * Copy the source response elements into the des response</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_copy_response</span>(<span class="pl-k">struct</span> _u_response * dest, <span class="pl-k">const</span> <span class="pl-k">struct</span> _u_response * source);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_clean_cookie</span>
<span class="pl-c"> * clean the cookie's elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_clean_cookie</span>(<span class="pl-k">struct</span> _u_cookie * cookie);

<span class="pl-c">/**</span>
<span class="pl-c"> * Copy the cookie source elements into dest elements</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_copy_cookie</span>(<span class="pl-k">struct</span> _u_cookie * dest, <span class="pl-k">const</span> <span class="pl-k">struct</span> _u_cookie * source);

<span class="pl-c">/**</span>
<span class="pl-c"> * create a new request based on the source elements</span>
<span class="pl-c"> * returned value must be free'd</span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_request * <span class="pl-en">ulfius_duplicate_request</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request);

<span class="pl-c">/**</span>
<span class="pl-c"> * create a new response based on the source elements</span>
<span class="pl-c"> * return value must be free'd</span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_response * <span class="pl-en">ulfius_duplicate_response</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_response * response);</pre></div>

<h3>
<a id="memory-management" class="anchor" href="#memory-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Memory management</h3>

<p>The Ulfius framework will automatically free the variables referenced by the request and responses structures, so you must use dynamically allocated values for the response pointers.</p>

<h3>
<a id="cookie-management" class="anchor" href="#cookie-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cookie management</h3>

<p>The map_cookie structure will contain a set of key/values to set the cookies. You can use the function <code>ulfius_add_cookie_to_response</code> in your callback function to facilitate cookies management. This function is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_add_cookie_to_header</span>
<span class="pl-c"> * add a cookie to the cookie map</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_add_cookie_to_response</span>(<span class="pl-k">struct</span> _u_response * response, <span class="pl-k">const</span> <span class="pl-k">char</span> * key, <span class="pl-k">const</span> <span class="pl-k">char</span> * value, <span class="pl-k">const</span> <span class="pl-k">char</span> * expires, <span class="pl-k">const</span> <span class="pl-c1">uint</span> max_age, 
                                  <span class="pl-k">const</span> <span class="pl-k">char</span> * domain, <span class="pl-k">const</span> <span class="pl-k">char</span> * path, <span class="pl-k">const</span> <span class="pl-k">int</span> secure, <span class="pl-k">const</span> <span class="pl-k">int</span> http_only);</pre></div>

<h3>
<a id="file-upload" class="anchor" href="#file-upload" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>File upload</h3>

<p>Ulifius allows file upload to the server. Beware that an uploaded file will be stored in the request object in memory, so uploading large files may dramatically slow the application or even crash it, depending on your system. An uploaded file is stored in the <code>request-&gt;map_body</code> structure. You can use <code>u_map_get_length</code> to get the exact length of the file as it may not be a string format.</p>

<p>If you want to limit the size of a post parameter, if you want to limit the file size for example, set the value <code>struct _u_instance.max_post_param_size</code>. Files or post data exceeding this size will be truncated to the size <code>struct _u_instance.max_post_param_size</code>. If this parameter is 0, then no limit is set. Default value is 0.</p>

<p>See <code>examples/sheep_counter</code> for a file upload example.</p>

<h3>
<a id="streaming-data" class="anchor" href="#streaming-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Streaming data</h3>

<p>If you need to stream data, i.e. send a variable and potentially large amount of data, you can define and use <code>stream_callback_function</code> in the <code>struct _u_response</code>.</p>

<p>Not that if you stream data to the client, any data that was in the <code>response-&gt;*_body</code> will be ignored. You must at least set the function pointer <code>struct _u_response.stream_callback</code> to stream data. Set <code>stream_size</code> to -1 if you don't know the size of the data you need to send, like in audio stream for example. Set <code>stream_block_size</code> according to you system resources to avoid out of memory errors, also, set <code>stream_callback_free</code> with a pointer to a function that will free values allocated by your stream callback function, as a <code>close()</code> file for example, and finally, you can set <code>stream_user_data</code> to a pointer.</p>

<p>You can use the function <code>ulfius_set_stream_response</code> to set those parameters.</p>

<p>The prototype of the <code>stream_callback</code> function is the following:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">stream_callback</span> (<span class="pl-k">void</span> * stream_user_data, <span class="pl-c">// Your predefined user_data</span>
                    <span class="pl-c1">uint64_t</span> offset,          <span class="pl-c">// the position of the current data to send</span>
                    <span class="pl-k">char</span> * out_buf,           <span class="pl-c">// The output buffer to fill with data</span>
                    <span class="pl-c1">size_t</span> max);              <span class="pl-c">// the max size of data to be put in the out_buf</span></pre></div>

<p>The return value must be the size of the data put in <code>out_buf</code>.</p>

<p>This function will be recalled in loop as long as the client has the connection opened.</p>

<p>If you want to close the stream from the server side, return <code>ULFIUS_STREAM_END</code> in the <code>stream_callback</code> function. If you a problem occured, you can close the connection with a <code>ULFIUS_STREAM_ERROR</code> return value.</p>

<p>While the <code>stream_callback_free</code> function is as simple as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">stream_callback_free</span> (<span class="pl-k">void</span> * stream_user_data);</pre></div>

<p>Check the program <code>stream_example</code> in the example folder.</p>

<h3>
<a id="character-encoding" class="anchor" href="#character-encoding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Character encoding</h3>

<p>You may be careful with characters encoding if you use non UTF8 characters in your application or webservice, and especially if you use different encodings in the same application. Ulfius has not been fully tested in cases like that.</p>

<h3>
<a id="struct-_u_map-api" class="anchor" href="#struct-_u_map-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>struct _u_map API</h3>

<p>The <code>struct _u_map</code> is a simple key/value mapping API used in the requests and the response for setting parameters. The available functions to use this structure are:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * initialize a struct _u_map</span>
<span class="pl-c"> * this function MUST be called after a declaration or allocation</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_init</span>(<span class="pl-k">struct</span> _u_map * map);

<span class="pl-c">/**</span>
<span class="pl-c"> * free the struct _u_map's inner components</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_clean</span>(<span class="pl-k">struct</span> _u_map * u_map);

<span class="pl-c">/**</span>
<span class="pl-c"> * free the struct _u_map and its components</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_clean_full</span>(<span class="pl-k">struct</span> _u_map * u_map);

<span class="pl-c">/**</span>
<span class="pl-c"> * free an enum return by functions u_map_enum_keys or u_map_enum_values</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_clean_enum</span>(<span class="pl-k">char</span> ** array);

<span class="pl-c">/**</span>
<span class="pl-c"> * returns an array containing all the keys in the struct _u_map</span>
<span class="pl-c"> * return an array of char * ending with a NULL element</span>
<span class="pl-c"> */</span>
<span class="pl-k">const</span> <span class="pl-k">char</span> ** <span class="pl-en">u_map_enum_keys</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map);

<span class="pl-c">/**</span>
<span class="pl-c"> * returns an array containing all the values in the struct _u_map</span>
<span class="pl-c"> * return an array of char * ending with a NULL element</span>
<span class="pl-c"> */</span>
<span class="pl-k">const</span> <span class="pl-k">char</span> ** <span class="pl-en">u_map_enum_values</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map);

<span class="pl-c">/**</span>
<span class="pl-c"> * return true if the sprcified u_map contains the specified key</span>
<span class="pl-c"> * false otherwise</span>
<span class="pl-c"> * search is case sensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_has_key</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * return true if the sprcified u_map contains the specified value</span>
<span class="pl-c"> * false otherwise</span>
<span class="pl-c"> * search is case sensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_has_value</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * return true if the sprcified u_map contains the specified value up until the specified length</span>
<span class="pl-c"> * false otherwise</span>
<span class="pl-c"> * search is case sensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_has_value_binary</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * value, <span class="pl-c1">size_t</span> length);

<span class="pl-c">/**</span>
<span class="pl-c"> * return true if the sprcified u_map contains the specified key</span>
<span class="pl-c"> * false otherwise</span>
<span class="pl-c"> * search is case insensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_has_key_case</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * return true if the sprcified u_map contains the specified value</span>
<span class="pl-c"> * false otherwise</span>
<span class="pl-c"> * search is case insensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_has_value_case</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * add the specified key/value pair into the specified u_map</span>
<span class="pl-c"> * if the u_map already contains a pair with the same key, replace the value</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_put</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * add the specified key/binary value pair into the specified u_map</span>
<span class="pl-c"> * if the u_map already contains a pair with the same key,</span>
<span class="pl-c"> * replace the value at the specified offset with the specified length</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_put_binary</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key, <span class="pl-k">const</span> <span class="pl-k">char</span> * value, <span class="pl-c1">uint64_t</span> offset, <span class="pl-c1">size_t</span> length);

<span class="pl-c">/**</span>
<span class="pl-c"> * get the value length corresponding to the specified key in the u_map</span>
<span class="pl-c"> * return -1 if no match found</span>
<span class="pl-c"> * search is case sensitive</span>
<span class="pl-c"> */</span>
<span class="pl-c1">size_t</span> <span class="pl-en">u_map_get_length</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * get the value length corresponding to the specified key in the u_map</span>
<span class="pl-c"> * return -1 if no match found</span>
<span class="pl-c"> * search is case insensitive</span>
<span class="pl-c"> */</span>
<span class="pl-c1">size_t</span> <span class="pl-en">u_map_get_case_length</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * get the value corresponding to the specified key in the u_map</span>
<span class="pl-c"> * return NULL if no match found</span>
<span class="pl-c"> * search is case sensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">const</span> <span class="pl-k">char</span> * <span class="pl-en">u_map_get</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * get the value corresponding to the specified key in the u_map</span>
<span class="pl-c"> * return NULL if no match found</span>
<span class="pl-c"> * search is case insensitive</span>
<span class="pl-c"> */</span>
<span class="pl-k">const</span> <span class="pl-k">char</span> * <span class="pl-en">u_map_get_case</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove an pair key/value that has the specified key</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_from_key</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove all pairs key/value that has the specified key (case insensitive search)</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_from_key_case</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove all pairs key/value that has the specified value</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_from_value</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove all pairs key/value that has the specified value (case insensitive search)</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_from_value_case</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * value);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove all pairs key/value that has the specified value up until the specified length</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if key was not found, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_from_value_binary</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">char</span> * key, <span class="pl-c1">size_t</span> length);

<span class="pl-c">/**</span>
<span class="pl-c"> * remove the pair key/value at the specified index</span>
<span class="pl-c"> * return U_OK on success, U_NOT_FOUND if index is out of bound, error otherwise</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_remove_at</span>(<span class="pl-k">struct</span> _u_map * u_map, <span class="pl-k">const</span> <span class="pl-k">int</span> index);

<span class="pl-c">/**</span>
<span class="pl-c"> * Create an exact copy of the specified struct _u_map</span>
<span class="pl-c"> * return a reference to the copy, NULL otherwise</span>
<span class="pl-c"> * returned value must be free'd after use</span>
<span class="pl-c"> */</span>
<span class="pl-k">struct</span> _u_map * <span class="pl-en">u_map_copy</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * source);

<span class="pl-c">/**</span>
<span class="pl-c"> * Return the number of key/values pair in the specified struct _u_map</span>
<span class="pl-c"> * Return -1 on error</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">u_map_count</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_map * source);</pre></div>

<h3>
<a id="send-http-request-api" class="anchor" href="#send-http-request-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Send HTTP request API</h3>

<p>The functions <code>int ulfius_send_http_request(const struct _u_request * request, struct _u_response * response)</code> and <code>int ulfius_send_http_streaming_request(const struct _u_request * request, struct _u_response * response, size_t (* write_body_function)(void * contents, size_t size, size_t nmemb, void * user_data), void * write_body_data)</code> are based on <code>libcurl</code> api.</p>

<p>It allows to send an http request with the parameters specified by the <code>_u_request</code> structure. Use the parameter <code>_u_request.http_url</code> to specify the distant url to call.</p>

<p>You can fill the maps in the <code>_u_request</code> structure with parameters, they will be used to build the request. Note that if you fill <code>_u_request.map_post_body</code> with parameters, the content-type <code>application/x-www-form-urlencoded</code> will be use to encode the data.</p>

<p>The response parameters is stored into the <code>_u_response</code> structure. If you specify NULL for the response structure, the http call will still be made but no response details will be returned. If you use <code>ulfius_send_http_request</code>, the response body will be stored in the parameter <code>response-&gt;*body*</code>, if you use <code>ulfius_send_http_streaming_request</code>, the response body will be available in the <code>write_body_function</code> specified in the call. The <code>ulfius_send_http_streaming_request</code> can be used for streaming data or large response.</p>

<p>Return value is <code>U_OK</code> on success.</p>

<p>This functions are defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_send_http_request</span>
<span class="pl-c"> * Send a HTTP request and store the result into a _u_response</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_send_http_request</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, <span class="pl-k">struct</span> _u_response * response);

<span class="pl-c">/**</span>
<span class="pl-c"> * ulfius_send_http_streaming_request</span>
<span class="pl-c"> * Send a HTTP request and store the result into a _u_response</span>
<span class="pl-c"> * Except for the body which will be available using write_body_function in the write_body_data</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_send_http_streaming_request</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> _u_request * request, 
                                       <span class="pl-k">struct</span> _u_response * response, 
                                       <span class="pl-en">size_t</span> (* write_body_function)(<span class="pl-k">void</span> * contents, 
                                                                      <span class="pl-c1">size_t</span> size, 
                                                                      <span class="pl-c1">size_t</span> nmemb, 
                                                                      <span class="pl-k">void</span> * user_data), 
                                       void * write_body_data);</pre></div>

<h3>
<a id="send-smtp-request-api" class="anchor" href="#send-smtp-request-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Send SMTP request API</h3>

<p>The function <code>ulfius_send_smtp_email</code> is used to send emails using a smtp server. It is based on <code>libcurl</code> API.</p>

<p>It's used to send emails (without attached files) via a smtp server.</p>

<p>This function is defined as:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * Send an email</span>
<span class="pl-c"> * host: smtp server host name</span>
<span class="pl-c"> * port: tcp port number (optional, 0 for default)</span>
<span class="pl-c"> * use_tls: true if the connection is tls secured</span>
<span class="pl-c"> * verify_certificate: true if you want to disable the certificate verification on a tls server</span>
<span class="pl-c"> * user: connection user name (optional, NULL: no user name)</span>
<span class="pl-c"> * password: connection password (optional, NULL: no password)</span>
<span class="pl-c"> * from: from address (mandatory)</span>
<span class="pl-c"> * to: to recipient address (mandatory)</span>
<span class="pl-c"> * cc: cc recipient address (optional, NULL: no cc)</span>
<span class="pl-c"> * bcc: bcc recipient address (optional, NULL: no bcc)</span>
<span class="pl-c"> * subject: email subject (mandatory)</span>
<span class="pl-c"> * mail_body: email body (mandatory)</span>
<span class="pl-c"> * return U_OK on success</span>
<span class="pl-c"> */</span>
<span class="pl-k">int</span> <span class="pl-en">ulfius_send_smtp_email</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> * host, 
                           <span class="pl-k">const</span> <span class="pl-k">int</span> port, 
                           <span class="pl-k">const</span> <span class="pl-k">int</span> use_tls, 
                           <span class="pl-k">const</span> <span class="pl-k">int</span> verify_certificate, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * user, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * password, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * from, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * to, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * cc, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * bcc, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * subject, 
                           <span class="pl-k">const</span> <span class="pl-k">char</span> * mail_body);</pre></div>

<h3>
<a id="example-source-code" class="anchor" href="#example-source-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example source code</h3>

<p>Example programs are available to see the different functionalities available, see <code>example</code> folder for detailed sample source codes and documentation.</p>

<h3>
<a id="questions-problems-" class="anchor" href="#questions-problems-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions, problems ?</h3>

<p>I'm open for questions and suggestions, feel free to open an issue or send a pull request if you feel like it!</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/babelouest/ulfius/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/babelouest/ulfius/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/babelouest/ulfius"></a> is maintained by <a href="https://github.com/babelouest">babelouest</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
